---
title: "C语言中的值传递和地址传递"
date: 2025-06-29
categories: [c语言学习]
categories: [c语言学习]  # 分类（可选）
tags: [学习，c语言]       # 标签（可选）
---

* 在 C 语言中，函数参数传递有值传递（Pass by Value）和地址传递（Pass by Address）两种方式，它们的主要区别如下：

### **1. 值传递（Pass by Value）**

**定义**：函数接收参数值的**副本**，而不是原始变量本身。
**特点**：
- **不会修改原始数据**：函数内对形参的修改不影响实参。
- **内存占用**：形参占用独立内存空间，复制实参的值。
- **数据类型限制**：适用于基本数据类型（如 `int`、`char`、`float` 等）。

**代码示例**：

```c
#include <stdio.h>

void increment(int a) {
    a++; // 修改的是副本
    printf("函数内：a = %d\n", a); // 输出 11
}

int main() {
    int x = 10;
    increment(x);
    printf("main函数：x = %d\n", x); // 输出 10（x未被修改）
    return 0;
}
```

### **2. 地址传递（Pass by Address）**

**定义**：通过传递指针（地址），允许函数间接访问原始数据。
**特点**：

- **可修改原始数据**：通过解引用（`*`）操作直接修改实参的值。
- **传递指针**：实参需为指针类型（如 `&x` 或指针变量）。
- 用途：
  - 修改函数外的变量。
  - 传递大型数据（如结构体），避免复制开销。

**代码示例**： 

```c
#include <stdio.h>

void increment(int *p) {
    (*p)++; // 通过指针修改原始数据
    printf("函数内：*p = %d\n", *p); // 输出 11
}

int main() {
    int x = 10;
    increment(&x); // 传递x的地址
    printf("main函数：x = %d\n", x); // 输出 11（x被修改）
    return 0;
}
```



------

### **关键区别总结**

|        **特性**        |        **值传递**        |     **地址传递**     |
| :--------------------: | :----------------------: | :------------------: |
|      **传递内容**      |       变量值的副本       |    变量的内存地址    |
| **原始数据是否可修改** |        ❌ 不可修改        |   ✅ 可通过指针修改   |
|      **内存开销**      | 复制数据（小数据效率高） | 只传递地址（效率高） |
|      **适用场景**      |       基本数据类型       | 指针、数组、结构体等 |
|    **函数参数写法**    |    `void func(int a)`    | `void func(int *a)`  |
|      **实参写法**      |        `func(x)`         |      `func(&x)`      |



### **深入理解**

- **C 语言只有值传递**：地址传递本质是**传递指针的值**（指针本身是一个变量，其值是地址）。
  - <font color=red>c语言中的所有参数传递均是值传递</font>
  - 地址传递的本质是指针的值传递，传递地址的值（即指针的值）
  - 传递的过程中复制的是地址的本身（指针值），而不是原始数据
  - 指针占用的内存大小固定（通常4或8字节），与它指向的数据大小无关
- **数组的特殊性**：传递数组名时实际传递的是首元素地址（`arr` 等价于 `&arr[0]`）。
- **效率对比**：地址传递适合处理大尺寸数据（如结构体），避免值传递的复制开销。

```c
// 值传递结构体：复制整个结构体（低效）
void updateStruct(MyStruct s);

// 地址传递结构体：只传递指针（高效）
void updateStruct(MyStruct *s);
```

### 内存开销对比

| **传递方式** |     **传递内容**     |      **复制对象**      |              **内存开销**              |
| :----------: | :------------------: | :--------------------: | :------------------------------------: |
|    值传递    |      原始数据值      |      整个数据对象      | 与数据大小相同 (int=4B, struct=100B等) |
|   地址传递   | 指向数据的指针(地址) | 指针本身的值(内存地址) |           固定大小 (4B或8B)            |

### 为什么地址传递效率更高？

假设我们有一个包含1000个int的结构体：

```c
struct BigData {
    int arr[1000]; // 占用4000字节(4字节/int * 1000)
};

// 值传递 - 复制整个结构体
void processValue(struct BigData data) { 
    // 函数调用时复制4000字节
}

// 地址传递 - 只复制指针
void processPointer(struct BigData *ptr) {
    // 函数调用时只复制指针(4或8字节)
}

int main() {
    struct BigData big;
    
    // 4000字节复制
    processValue(big);  
    
    // 仅4-8字节复制（指针大小）
    processPointer(&big);
}
```

### 关键解疑：地址传递的内存开销

1. **开销来源**：复制指针变量本身的值（一个内存地址）

2. 开销大小：

   - 32位系统：4字节
   - 64位系统：8字节

3. 与原始数据无关：

   ```c
   // 下面两个函数调用复制的数据量相同：
   char *p1; // 指向1字节数据
   double big[10000]; // 占用80KB
   
   func(&p1);    // 复制4/8字节（地址）
   func(&big);   // 复制4/8字节（地址）相同！
   ```

### 为什么不是真正的零开销？

虽然地址传递减少了数据复制，但仍有微小开销：

1. 需要复制地址值（虽然很小）
2. 访问数据需要额外解引用操作（通过指针访问）

### 深层原理图解

```mariadb
原始数据          函数参数
┌──────────┐     ┌──────────┐
│   data   │     │   copy   │  <- 值传递: 复制整个data
└──────────┘     └──────────┘

原始数据地址      函数指针参数
┌──────────┐     ┌─────┐
│ 0x1000   │<┐   │0x1000│  <- 地址传递: 只复制地址值
└──────────┘ │   └─────┘
             │      │
             └──────┘
```

在这个图中：

- 值传递复制的是整个蓝色方块（原始数据）
- 地址传递只复制橙色方块（地址值），箭头是原始数据的引用

### 实践建议

1. **小型数据**：int等基本类型直接用值传递

2. **大型数据**：结构体、数组优先用指针传递

3. 避免意外修改

   ```c
   // 使用const保护指针指向的数据
   void safePrint(const BigData *p) {
       // 可以读取*p但不能修改
   }
   ```
